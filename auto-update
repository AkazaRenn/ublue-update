#!/usr/bin/env python3

import psutil
import notify2
import os
import subprocess
import logging
import configparser


default_config = """
[checks]
battery_percent = 50
cpu_load = 50
"""

def check_cpu_load(max_cpu_load):
# get load average percentage in last 5 minutes: https://psutil.readthedocs.io/en/latest/index.html?highlight=getloadavg
	cpu_load = psutil.getloadavg()[1] / psutil.cpu_count() * 100
	return {"passed": cpu_load < max_cpu_load, "message": f"CPU load is above {max_cpu_load}%"}


def check_network_status():
	network_status = psutil.net_if_stats()
# check each network interface
	network_up = False
	for key in network_status.keys():
		if key != "lo":
			if network_status[key][0]:
				network_up = True
				break
	return {"passed": network_up, "message": "Network not enabled"}


def check_battery_status(min_battery_percent):
	battery_status = psutil.sensors_battery()
	# null safety on the battery variable, it returns "None" when the system doesn't have a battery
	battery_pass = True
	if battery_status != None:
		battery_check = (battery_status.percent > min_battery_percent or battery_status.power_plugged)
	return {"passed": battery_pass, "message": f"Battery less than {min_battery_percent}%"}

def checks(config):
	min_battery_percent = float(config['checks']['battery_percent'])
	max_cpu_load = float(config['checks']['cpu_load'])
	
	update_inhibitors = [
		check_network_status(),
		check_battery_status(min_battery_percent),
		check_cpu_load(max_cpu_load),
	]
	update_checks_failed = False
	update_fail_conditions = []
	for inhibitor_result in update_inhibitors:
		if not inhibitor_result["passed"]:
			update_passed = True
			print(f"System could not upgrade due to: {inhibitor_result['message']}")
	return update_checks_failed, update_inhibitors


def load_config():
# load config values
	config_paths = [
		os.path.expanduser('~/.config/auto-update/auto-update.conf'),
		"/etc/auto-update/auto-update.conf",
		"/usr/etc/auto-update/auto-update.conf"
		]

	config_path = ""
	for path in config_paths:
		if os.path.isfile(path):
			config_path = path
			break

	if config_path == "":
		config_path = config_paths[0]
		os.makedirs(os.path.dirname(config_path))
		with open(config_path, "w") as f:
			f.write(default_config)

	config = configparser.ConfigParser()
	config.read(config_path)
	return config


def main():
# setup logging
	logging.basicConfig(
			format="[%(asctime)s] %(name)s:%(levelname)s | %(message)s",
			level=os.getenv("UBLUE_LOG", default=logging.INFO),
	)

	notify2.init('auto-update')

	update_checks_failed, update_fail_conditions = checks(load_config())
	if update_checks_failed:
		n = notify2.Notification("System Updater","System doesn't pass " + update_inhibitors[key][1] + " check \n aborting ...","notification-message-im")
		n.show()
		exit(0)

# system checks passed
	n = notify2.Notification("System Updater","System passed checks \n updating ...","notification-message-im")
	n.show()

	root_dir = "/etc/update.d/"

# execute update commands
	for root, dirs, files in os.walk(root_dir):
		for file in files:
			full_path = root_dir + "/" + str(file)
			list_files = subprocess.run([full_path])

# system is done updating
	n = notify2.Notification("System Updater","System update complete \n reboot for changes to take effect","notification-message-im")
	n.show()

main()
